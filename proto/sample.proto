syntax = "proto3";

option go_package = "/personpb";

import "google/protobuf/timestamp.proto";

message Person {
    string name = 1;
    int32 age = 2;
    repeated PhoneNumber phone_numbers = 3;
    google.protobuf.Timestamp last_updated = 4;
}

message PhoneNumber {
    string number = 1;
    PhoneNumberType type = 2;
}

enum PhoneNumberType {
    MOBILE =0;
    HOME = 1;
    WORK = 2;
}

message CreatePersonRequest {
    Person person = 1;
}
message CreatePersonResponse {
    Person person = 1;
}

message ReadPersonRequest {
    string person_number = 1;
}

message ReadPersonResponse {
    Person person = 1;
}

message ListPersonRequest {

}

message ListPersonResponse {
    Person person = 1;
}

service PersonService {
    rpc CreatePerson(CreatePersonRequest) returns (CreatePersonResponse); // 새로운 Person생성
    rpc ReadPerson(ReadPersonRequest) returns(ReadPersonResponse); // 기존에 있는 Person Read
    rpc ListPerson(ListPersonRequest) returns(ListPersonResponse); // 전체 Person가져오기
}


/**

proto에서는 message가 하나의 struct처럼 동작을 합니다.
해당 field내부에는 다음과 같은 예시로 값들이 들어가게 되고, value는 고유 합니다.
-> 즉 중복이 일어나서는 안됩니다.

message내부의 field타입은 다양하게 있습니다.

1. singular -> 가장 일반적인 타입입니다. 0,이나 다른 값들을 마음대로 가질 수 있지만 한개 이상은 가질 수 없습니다.
2. repeated -> 하나의 필드에 여러 개의 값을 가질 수 있는 타입이니다. 즉 위에 있는 예시로 들자면, phone_number는 여러 객체의 PhoneNumber를 담을 수 있다.
3. map -> 용어와 같이 키-벨류 형태로 데이터를 표현합니다. Ex : map<string int32> test = 4;
4. reserved -> 예약된 필드라는 의미 입니다. 선언이 된다면 해당 필드에 사용된 value값들을 다른 필드에서 활요이 불가능 합니다.
-> 해당 조건은 같은 message에서만 유효합니다.

이후 함수는 다음과 같이 service에 작성을 하게 됩니다.

이떄 사용하는 함수들의 이름을 rpc로 지정을 하고, 인자들에 대해서 각각의 message를 만들어 줍니다.
- 이러한 작성법은 어렵지 않기 떄문에 부가적인 설명은 하지 않겠습니다.


option은 go에서 생성된 코드가 속하는 것을 지정 합니다. 즉 이렇게 만들어진 proto3코드는 personpb라는 패키지를 통해서 접근 가능합니다.


추가로 별도 의존성을 위해서 다음 명령어를 실행합니다.
- go install google.golang.org/protobuf/cmd/protoc-gen-go@latest


cli를 통해서 작성한 proto코드를 go파일로 만드는 명령어는 다음과 같습니다.
- protoc --go_out=. --go-grpc_out=. proto/sample.proto

둘다 현재 경로에 대해서 out하게 되고, option에서 준 네이밍에 따라서 하나의 go파일이 만들어 지게 됩니다.


**/


